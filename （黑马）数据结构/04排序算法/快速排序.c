//快速排序（极快、不稳定）
//时间复杂度：O(nlogn)
/*
快速排序的核心思想：从一堆数组中取出一个基准中心轴（一般这个基准中心轴取数组最左端的值），
然后从右端的值开始遍历比较（从哪边取基准值，就从另一边开始比较），当有值符合条件移动的时候，索引就要换一段开始比较（因为要腾出空间），将小于该基准的元素放到这
个中心轴的左边,大于这个基准的元素放到该基准的右边，这样不断排序，当左边索引值大于等于右边
索引值的时候完成一次排序，即这个基准就是有序的了。
然后对基准的左边再进行快速排序，基准的右边再进行快速排序。不断递归，最终完成整个数组的排序。
*/
 void quickSort(int arr[], int L, int R)//传入待处理数组、左起始点、右起始点
{
    int left = L;//左起点
    int right  = R;//右起点
    int pivot = arr[left];//先将最左端的值作为基准值取出
    if(left >= right) 
        return;
    while(left < right)//当传入的数组确实有长度，即长度大于1时，开始排序
    {
        while(left < right && arr[right] >= pivot)//当右边的元素比基准值大的时候，保持不动继续比较下一个元素，否则放到基准中心轴的左边
        {
            right--;
        }
        arr[left] = arr[right];

        while(left < right && arr[left] <= pivot)//当左边的元素比基准值小的时候，保持不动继续比较下一个元素，否则放到基准中心轴的右边
        {
            left++;
        }
        arr[right] = arr[left];//当两个索引值相等的时候，就将基准值插入该位置，这个时候基准值就在他所在的有序位置上，接下来对基准中心轴的左右分别在进行快排
    }
    arr[left] = pivot;

    quickSort(arr, L, left-1);//左边快排递归
    quickSort(arr, right+1, R);//右边快排递归
}